name: dotnet-k8s-stack

on:
  push:
    branches:
      - master
      - dev
      - feature/**

env:
  ENVIRONMENT: dev
  PROVIDER: azure
  LOCATION: eastus
  TERRAFORM_BACKEND_GROUP_NAME: k-eco-terraform
  STORAGE_ACCOUNT_NAME: kecoterraform
  STORAGE_CONTAINER_NAME: terraform
  STORAGE_CONTAINER_KEY: terraform.tfstate
  GROUP_NAME: k-eco
  CLUSTER_NAME: k-cluster
  ACR_NAME: kecoacr
  AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}
  ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
  DOMAIN_NAME: ${{ secrets.PUBLIC_DOMAIN_NAME }}
  K8S_CLIENT_ID: ${{ secrets.K8S_CLIENT_ID }}
  K8S_CLIENT_SECRET: ${{ secrets.K8S_CLIENT_SECRET }}
  K8S_OBJECT_ID: ${{ secrets.K8S_OBJECT_ID }}
  SQL_IMAGE_NAME: "adventureworks2017-mssql2019-ubuntu16.04-backup-only"
  SQL_IMAGE_VERSION: "1.0"
  API_IMAGE_NAME: "adventureworks-api-dotnet3.1"
  API_IMAGE_VERSION: "1.0"
  APP_IMAGE_NAME: "adventureworks-app-dotnet3.1"
  APP_IMAGE_VERSION: "1.0"

jobs:
  set-environment:
    runs-on: ubuntu-latest
    
    steps:
      - name: 'Set environment to dev'
        if: contains(github.ref, 'feature')
        run: |
          echo "::set-env name=ENVIRONMENT::dev"

      - name: 'Set environment to dev'
        if: endsWith(github.ref, '/dev')
        run: |
          echo "::set-env name=ENVIRONMENT::dev"

      - name: 'Set environment to prod'
        if: endsWith(github.ref, '/master')
        run: |
          echo "::set-env name=ENVIRONMENT::prod"

  backend:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v2

      - name: 'Login via Azure CLI'
        uses: azure/login@v1
        with:
          creds: ${{ toJSON(env.AZURE_CREDENTIALS) }}
      
      - name: 'Azure CLI script file'
        id: setup-terraform-backend
        uses: azure/CLI@v1
        with:
          azcliversion: 2.8.0
          inlineScript: |
            chmod +x $GITHUB_WORKSPACE/infrastructure/terraform/$PROVIDER/backend/setup-terraform-backend.sh
            $GITHUB_WORKSPACE/infrastructure/terraform/$PROVIDER/backend/setup-terraform-backend.sh -g $TERRAFORM_BACKEND_GROUP_NAME -l $LOCATION --storage-account-name $STORAGE_ACCOUNT_NAME --storage-container-name $STORAGE_CONTAINER_NAME

  infrastructure:
    needs: backend
    runs-on: ubuntu-latest
    env:
      TFVARS_FILE: "workflow.tfvars"
    outputs:
      #kube_config: ${{ steps.output.outputs.kube_config }}
      ip_address: ${{ steps.output.outputs.ip_address }}
      acr_login_server: ${{ steps.output.outputs.acr_login_server }}

    steps:
      - uses: actions/checkout@v2
      - uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: 0.12.28
          terraform_wrapper: false

      - name: 'Set working directory'
        run: |
          echo "::set-env name=WORKING_DIRECTORY::$GITHUB_WORKSPACE/infrastructure/terraform/$PROVIDER/"
      
      - name: 'create tfvars file'
        run: |
          cd $WORKING_DIRECTORY
          cat <<EOF > $TFVARS_FILE
          resource_group_name         = "$GROUP_NAME"
          location                    = "$LOCATION"
          cluster_name                = "$CLUSTER_NAME"
          domain_name                 = "$DOMAIN_NAME"
          acr_name                    = "$ACR_NAME"
          client_id                   = "$K8S_CLIENT_ID"
          client_secret               = "$K8S_CLIENT_SECRET"
          service_principal_object_id = "$K8S_OBJECT_ID"
          environment                 = "$ENVIRONMENT"
          EOF

      - name: 'terraform fmt'
        id: fmt
        run: |
          cd $WORKING_DIRECTORY
          terraform fmt
        continue-on-error: true

      - name: 'terraform init'
        id: init
        run: |
          cd $WORKING_DIRECTORY
          terraform init \
            -backend-config="resource_group_name=$TERRAFORM_BACKEND_GROUP_NAME" \
            -backend-config="storage_account_name=$STORAGE_ACCOUNT_NAME" \
            -backend-config="container_name=$STORAGE_CONTAINER_NAME" \
            -backend-config="key=$STORAGE_CONTAINER_KEY" \
      
      - name: 'terraform validate'
        id: validate
        run: |
          cd $WORKING_DIRECTORY
          terraform validate -no-color
      
      - name: 'terraform plan'
        id: plan
        run: |
          cd $WORKING_DIRECTORY
          terraform plan -no-color \
            -var-file "$TFVARS_FILE"
      
      - name: 'terraform apply'
        id: apply
        run: |
          cd $WORKING_DIRECTORY
          terraform apply --auto-approve \
            -var-file "$TFVARS_FILE"

      - name: 'terraform output'
        id: output
        run: |
          cd $WORKING_DIRECTORY
          echo "Azure DNS name servers"
          terraform output name_servers
          #KUBE_CONFIG="$(terraform output kube_config)"
          IP_ADDRESS="$(terraform output ip_address)"
          ACR_LOGIN_SERVER="$(terraform output acr_login_server)"
          echo "::set-output name=ip_address::"$IP_ADDRESS""
          echo "::set-output name=acr_login_server::"$ACR_LOGIN_SERVER""

  image:
    needs: infrastructure
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./image
    steps:
      - uses: actions/checkout@v2

      - name: 'Login to Azure ACR'
        id: acr-login
        run: |
          docker login "${{ needs.infrastructure.outputs.acr_login_server }}" --username $ARM_CLIENT_ID --password $ARM_CLIENT_SECRET

      - name: 'Get backup'
        id: get-backup
        run: |
          cd sql
          chmod +x run-to-get-bak.sh
          ./run-to-get-bak.sh 

      - name: 'Build sql image'
        id: build-sql-image
        run: |
          cd sql
          docker build . -t ${{ needs.infrastructure.outputs.acr_login_server }}/$SQL_IMAGE_NAME:$SQL_IMAGE_VERSION
          docker push ${{ needs.infrastructure.outputs.acr_login_server }}/$SQL_IMAGE_NAME:$SQL_IMAGE_VERSION

      - name: 'Build api image'
        id: build-api-image
        run: |
          cd api
          docker build . -t ${{ needs.infrastructure.outputs.acr_login_server }}/$API_IMAGE_NAME:$API_IMAGE_VERSION
          docker push ${{ needs.infrastructure.outputs.acr_login_server }}/$API_IMAGE_NAME:$API_IMAGE_VERSION

      - name: 'Build app image'
        id: build-app-image
        run: |
          cd app
          docker build . -t ${{ needs.infrastructure.outputs.acr_login_server }}/$APP_IMAGE_NAME:$APP_IMAGE_VERSION
          docker push ${{ needs.infrastructure.outputs.acr_login_server }}/$APP_IMAGE_NAME:$APP_IMAGE_VERSION

  orchestration:
    needs: image
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./orchestration
    steps:
      - uses: actions/checkout@v2

      - name: 'Login via Azure CLI'
        uses: azure/login@v1
        with:
          creds: ${{ toJSON(env.AZURE_CREDENTIALS) }}
      
      - name: 'Azure CLI script file'
        id: get-aks-credentials
        uses: azure/CLI@v1
        with:
          azcliversion: 2.8.0
          inlineScript: |
            az aks get-credentials -g $GROUP_NAME -n $CLUSTER_NAME --overwrite

      #- name: 'helm install'
      #  id: install-helm
