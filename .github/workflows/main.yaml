name: dotnet-k8s-stack

on:
  push:
    branches:
      - master
      - dev
      - feature/**

env:
  PROVIDER: azure
  LOCATION: eastus
  TERRAFORM_BACKEND_GROUP_NAME: k-eco-terraform
  STORAGE_ACCOUNT_NAME: kecoterraform
  STORAGE_CONTAINER_NAME: terraform
  STORAGE_CONTAINER_KEY: terraform.tfstate
  GROUP_NAME: k-eco
  CLUSTER_NAME: k-cluster
  ACR_NAME: kecoacr
  ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
  DOMAIN_NAME: ${{ secrets.PUBLIC_DOMAIN_NAME }}
  K8S_CLIENT_ID: ${{ secrets.K8S_CLIENT_ID }}
  K8S_CLIENT_SECRET: ${{ secrets.K8S_CLIENT_SECRET }}
  K8S_OBJECT_ID: ${{ secrets.K8S_OBJECT_ID }}
  SQL_IMAGE_NAME: "adventureworks2017-mssql2019-ubuntu16.04-backup-only"
  SQL_IMAGE_VERSION: "1.0"
  API_IMAGE_NAME: "adventureworks-api-dotnet3.1"
  API_IMAGE_VERSION: "1.0"
  APP_IMAGE_NAME: "adventureworks-app-dotnet3.1"
  APP_IMAGE_VERSION: "1.0"
  HELM_INSTALL_NAME: adventureworks

jobs:
  get-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.output.outputs.environment }}
    
    steps:
      - name: 'Set environment to dev'
        if: contains(github.ref, 'feature')
        run: |
          echo "::set-env name=ENVIRONMENT::dev"

      - name: 'Set environment to dev'
        if: endsWith(github.ref, '/dev')
        run: |
          echo "::set-env name=ENVIRONMENT::dev"

      - name: 'Set environment to prod'
        if: endsWith(github.ref, '/master')
        run: |
          echo "::set-env name=ENVIRONMENT::prod"

      - name: 'Output environment'
        id: output
        echo "::set-output name=environment::$ENVIRONMENT"

  backend:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v2

      - name: 'Login via Azure CLI'
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: 'Set-up terraform backend'
        id: setup-terraform-backend
        run: |
          chmod +x $GITHUB_WORKSPACE/infrastructure/terraform/$PROVIDER/backend/setup-terraform-backend.sh
          $GITHUB_WORKSPACE/infrastructure/terraform/$PROVIDER/backend/setup-terraform-backend.sh -g $TERRAFORM_BACKEND_GROUP_NAME -l $LOCATION --storage-account-name $STORAGE_ACCOUNT_NAME --storage-container-name $STORAGE_CONTAINER_NAME

  infrastructure:
    needs: [get-environment, backend]
    runs-on: ubuntu-latest
    env:
      TFVARS_FILE: "workflow.tfvars"
    outputs:
      ip_address: ${{ steps.output.outputs.ip_address }}
      acr_login_server: ${{ steps.output.outputs.acr_login_server }}

    steps:
      - uses: actions/checkout@v2
      - uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: 0.12.28
          terraform_wrapper: false

      - name: 'Set working directory'
        run: |
          echo "::set-env name=WORKING_DIRECTORY::$GITHUB_WORKSPACE/infrastructure/terraform/$PROVIDER/"
      
      - name: 'create tfvars file'
        run: |
          cd $WORKING_DIRECTORY
          cat <<EOF > $TFVARS_FILE
          resource_group_name         = "$GROUP_NAME"
          location                    = "$LOCATION"
          cluster_name                = "$CLUSTER_NAME"
          domain_name                 = "$DOMAIN_NAME"
          acr_name                    = "$ACR_NAME"
          client_id                   = "$K8S_CLIENT_ID"
          client_secret               = "$K8S_CLIENT_SECRET"
          service_principal_object_id = "$K8S_OBJECT_ID"
          environment                 = "${{ needs.get-environment.outputs.environment }}"
          EOF

      - name: 'terraform fmt'
        id: fmt
        run: |
          cd $WORKING_DIRECTORY
          terraform fmt
        continue-on-error: true

      - name: 'terraform init'
        id: init
        run: |
          cd $WORKING_DIRECTORY
          terraform init \
            -backend-config="resource_group_name=$TERRAFORM_BACKEND_GROUP_NAME" \
            -backend-config="storage_account_name=$STORAGE_ACCOUNT_NAME" \
            -backend-config="container_name=$STORAGE_CONTAINER_NAME" \
            -backend-config="key=$STORAGE_CONTAINER_KEY" \
      
      - name: 'terraform validate'
        id: validate
        run: |
          cd $WORKING_DIRECTORY
          terraform validate -no-color
      
      - name: 'terraform plan'
        id: plan
        run: |
          cd $WORKING_DIRECTORY
          terraform plan -no-color \
            -var-file "$TFVARS_FILE"
      
      - name: 'terraform apply'
        id: apply
        run: |
          cd $WORKING_DIRECTORY
          terraform apply --auto-approve \
            -var-file "$TFVARS_FILE"

      - name: 'terraform output'
        id: output
        run: |
          cd $WORKING_DIRECTORY
          echo "Azure DNS name servers"
          terraform output name_servers
          IP_ADDRESS="$(terraform output ip_address)"
          ACR_LOGIN_SERVER="$(terraform output acr_login_server)"
          echo "::set-output name=ip_address::"$IP_ADDRESS""
          echo "::set-output name=acr_login_server::"$ACR_LOGIN_SERVER""

  image:
    needs: infrastructure
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./image
    steps:
      - uses: actions/checkout@v2

      - name: 'Login to Azure ACR'
        id: acr-login
        run: |
          docker login "${{ needs.infrastructure.outputs.acr_login_server }}" --username $ARM_CLIENT_ID --password $ARM_CLIENT_SECRET

      - name: 'Get backup'
        id: get-backup
        run: |
          cd sql
          chmod +x run-to-get-bak.sh
          ./run-to-get-bak.sh 

      - name: 'Build sql image'
        id: build-sql-image
        run: |
          cd sql
          docker build . -t ${{ needs.infrastructure.outputs.acr_login_server }}/$SQL_IMAGE_NAME:$SQL_IMAGE_VERSION
          docker push ${{ needs.infrastructure.outputs.acr_login_server }}/$SQL_IMAGE_NAME:$SQL_IMAGE_VERSION

      - name: 'Build api image'
        id: build-api-image
        run: |
          cd api
          docker build . -t ${{ needs.infrastructure.outputs.acr_login_server }}/$API_IMAGE_NAME:$API_IMAGE_VERSION
          docker push ${{ needs.infrastructure.outputs.acr_login_server }}/$API_IMAGE_NAME:$API_IMAGE_VERSION

      - name: 'Build app image'
        id: build-app-image
        run: |
          cd app
          docker build . -t ${{ needs.infrastructure.outputs.acr_login_server }}/$APP_IMAGE_NAME:$APP_IMAGE_VERSION
          docker push ${{ needs.infrastructure.outputs.acr_login_server }}/$APP_IMAGE_NAME:$APP_IMAGE_VERSION

  orchestration:
    needs: [get-environment, image, infrastructure]
    runs-on: ubuntu-latest
    env:
      HELM_VARIABLES_FILE: "vars.yaml"
      HELM_TEMPLATE_FILE: "values-template.yaml"
      HELM_VALUES_FILE: "values.yaml"
    defaults:
      run:
        working-directory: ./orchestration
    steps:
      - uses: actions/checkout@v2

      - name: 'Login via Azure CLI'
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: 'Get AKS credentials'
        id: get-aks-credentials
        run: |
            az aks get-credentials -g $GROUP_NAME -n $CLUSTER_NAME --overwrite

      - name: 'Replace Helm tokens'
        id: replace-helm-tokens
        run: |
          cat <<EOF > $HELM_VARIABLES_FILE
            ENVIRONMENT: ${{ needs.get-environment.outputs.environment }}
            CLUSTER_NAME: $CLUSTER_NAME
            IP_ADDRESS: ${{ needs.infrastructure.outputs.ip_address }}
            DOMAIN_NAME: $DOMAIN_NAME
            ACR_LOGIN_SERVER: ${{ needs.infrastructure.outputs.acr_login_server }}
            SQL_IMAGE_NAME: $SQL_IMAGE_NAME
            SQL_IMAGE_VERSION: $SQL_IMAGE_VERSION
            API_IMAGE_NAME: $API_IMAGE_NAME
            API_IMAGE_VERSION: $API_IMAGE_VERSION
            APP_IMAGE_NAME: $APP_IMAGE_NAME
            APP_IMAGE_VERSION: $APP_IMAGE_VERSION
          EOF

          chmod +x replace-helm-tokens.sh
          ./replace-helm-tokens.sh -f $HELM_VARIABLES_FILE --template-file $HELM_TEMPLATE_FILE --output-file $HELM_VALUES_FILE

      - name: 'helm dependency update'
        id: helm-dependency-update
        run: |
          helm dependency update

      - name: 'helm install'
        id: helm-install
        run: |
          helm upgrade -i -f $HELM_VALUES_FILE $HELM_INSTALL_NAME --create-namespace -n ${{ needs.get-environment.outputs.environment }} --atomic .
